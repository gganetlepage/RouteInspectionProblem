Raisonnement employé :

On a un graphe G(V,E)
avec : 
V : ensemble des sommets, correspondant à chaque carrefour de Paris
E : ensemble des rues de Paris

Le problème consiste en un problème de coursier chinois avec 10 véhicules.
Où l'on souhaite minimiser la distance du véhicule parcourant la plus grande distance.

D'abord, on résoud le problème comme si l'on n'avait qu'un seul véhicule, pour le simplifier (et mieux assimiler les particularités du problème)

___________________________________________________________________

A - Résolution du coursier chinois

Objectif : minimiser la distance totale parcourue par le coursier

1) Si le graphe était eulérien, le couriser pourrait passer par toutes les arrêtes, et ce en un unique passage en chacune d'entre elles.
Ce qui serait un cas optimal et la distance serait alors la somme des distances (ou poids de toutes les arêtes)

2) Le graphe ne l'est pas, on cherche donc à le rendre eulérien.
Un graphe eulérien si et seulement si tous ses sommets sont de degré pair.
Identifions les sommets de degré impair.

3) Construisons le graphe complet constitué de tous les sommets impairs (et uniquement eux). Les sommets sont tous adjacents entre eux pour être sûr de traiter tous les cas possibles (d'où la raison du graphe complet). Les arêtes peuvent être des arêtes existantes initialement ou bien des chaînes que l'on construit entre des sommets qui n'étaient pas adjacents.
Le nombre de sommets de degré impair est pair par construction. 
Le calcul de distance entre les différents sommets se fait via l'algorithme de Dijkstra. Utilisation de file de priorité, via la librarie heapq, pour améliorer la complexité temporelle.

4) Déterminons le couplage parfait, c'est-à-dire l'ensemble de N arêtes dans un graphe de 2N sommets, tel que chaque sommet soit de degré 1.
Ce couplage doit être de distance totale / poids total minimal. 
Couplage fait à l'aide d'un algorithme glouton : un sommet de degré 0 est sélectionné, on sélectionne l'arête de distance minimum avec un des autres sommets de degré 0. Ainsi les 2 sommets deviennent de degré 1, et on réitère jusqu'à ne plus avoir de sommet de degré 0.

5) Ainsi en ajoutant ces arêtes au graphe initial, tous les sommets deviennent de degré pair. 
Ainsi le graphe est eulérien. Donc le 1) est réalisé. La distance totale minimale est donc connue, c'est la somme des distances/poids de toutes les arêtes

B- Résolution du coursier chinois avec 10 véhicules

Objectif : Répartir correctement cette distance minimale

6) Cherchons maintenant à répartir cette distance selon 10 véhicules.
On peut employer un algorithme glouton :
le premier véhicule part de n'importe quel point, avance de sommet adjacent à sommet adjacent en passant par des arêtes qui n'ont pas encore été traversées.
 quand le véhicule dépasse 1/10 * distance totale, un autre véhicule prend la revèle et partant du dernier poids il réalise le même protocole.
 
 Le dernier véhicule passe par tous les sommets qui n'ont pas enore été traversés.
 
 _________________________________________________________
 
Idées d'amélioration (suite à la réflexion et au codage) :
 
1) L'algorithme glouton du couplage parfait ("point 4)" )est fait essentiellement par facilité. Il doit être amélioré pour une meilleure complexité temporelle

2) On peut réduire un peu plus la distance en utilisant le fait que l'on a 10 véhicules qui peuvent partir de n'importe où ("point 6").
Certains sommets n'ont pas besoin de devenir de degré pair si les véhicules débutent leurs tournées de ces sommets, si certaines arêtes ne sont pas ajoutées alors on s'évite leur poids associé.

3) Je n'ai pas réussi à réaliser le codage en entier du problème, je me suis arrêté au "point 4)"

Note : J'ai remplacé les sys.argv par des valeurs fixes dans mon main.py

